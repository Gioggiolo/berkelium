/** \page dev_guide Development Guide
 *
 *  <h3>Initialization and Destruction</h3>
 *
 *  Berkelium has some global initialization and destruction code that needs to
 *  be run once inside the process instantiating new windows (or web pages).
 *  \code
 *  Berkelium::init();
 *  \endcode
 *
 *  When the process is exiting, to ensure all resources are cleanly released,
 *  just call the cleanup function.
 *  \code
 *  Berkelium::destroy();
 *  \endcode
 *
 *  Ideally by the time you call the cleanup function, all windows would be
 *  destroyed, but if they aren't Berkelium will clean up their resources.
 *  However, be sure that WindowDelegates that are registered exist until the
 *  parent window they are listening to is destroyed or until after the cleanup
 *  method is called.
 *
 *  <h3>Creating and Interacting with Windows</h3>
 *
 *  Interaction with a web page (the equivalent of a tab in a regular browser)
 *  is performed via the Berkelium::Window class.  Simply instantiate the class,
 *  set its size, and point it to a location:
 *  \code
 *    Berkelium::Window* window = Berkelium::Window::create();
 *    window->resize(512, 512);
 *    std::string url = "http://berkelium.org";
 *    window->navigateTo(url.data(), url.length());
 *  \endcode
 *  This creates a web browser instance and loads the specified page, but
 *  doesn't do anything to display it -- that's your responsibility.  In order
 *  to display it, as well as receive other events, you'll set up a
 *  WindowDelegate.
 *
 *  Berkelium::WindowDelegate is an interface for listening for all types of
 *  events from a web page -- navigation, paint events, load progress, and so
 *  on. Default implementations that ignore events or handle them with sane
 *  defaults are provided, so you can implement a subclass which only handles
 *  the events you care about.  For instance, if you are only concerned with
 *  display, then implementing only Berkelium::WindowDelegate::onPaint is
 *  sufficient.
 *
 *  For instance, you might define the following class to handle paint events
 *  and pass them onto your drawing layer
 *  \code
 *  class MyDelegate : public Berkelium::WindowDelegate {
 *    virtual void onPaint(Window *wini, const unsigned char *bitmap_in, const Rect &bitmap_rect,
 *        int dx, int dy, const Rect &scroll_rect) {
 *      // handle paint events...
 *    }
 *  };
 *  \endcode
 *  and replace the above instantiation code with the following:
 *  \code
 *    Berkelium::Window* window = Berkelium::Window::create();
 *    window->resize(512, 512);
 *    window->setDelegate( new MyDelegate() );
 *    std::string url = "http://berkelium.org";
 *    window->navigateTo(url.data(), url.length());
 *  \endcode
 *  which adds a delegate to handle drawing.  The delegate would be invoked as
 *  necessary, passing the new display information into your application.
 *
 *  <h3>Injecting Input</h3>
 *
 *  (To come: injecting mouse and keyboard events)
 *
 *  <h3>Javascript Interaction</h3>
 *
 *  (To come: injecting javascript, receiving callbacks from javascript)
 *
 */
